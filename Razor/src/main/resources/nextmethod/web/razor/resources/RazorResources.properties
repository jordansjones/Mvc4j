activeParser.must.be.code.or.markup.parser=The active parser must the same as either the markup or code parser.
block.type.not.specified=Block cannot be built because a Type has not been specified in the BlockBuilder
# This is a literal used when composing parserError.* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.
blockName.code=code
# This is a literal used when composing parserError.* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.
blockName.explicitExpression=explicit expression
cancelBacktrack.must.be.called.within.lookahead=The "CancelBacktrack" method can be called only while in a look-ahead process started with the "BeginLookahead" method.
# This error should not be seen by users, it should only appear to internal developers, but I'm putting it in resources just in case
createCodeWriter.noCodeWriter=Cannot call CreateCodeWriter, a CodeWriter was not provided to the Create method
endBlock.called.without.matching.startBlock="EndBlock" was called without a matching call to "StartBlock".
errorComponent.character="%1$s" character
errorComponent.endOfFile=end of file
errorComponent.newline=line break
errorComponent.whitespace=space or line break
htmlSymbol.newLine=<<newline sequence>>
htmlSymbol.razorComment=<<razor comment>>
htmlSymbol.text=<<text>>
htmlSymbol.whiteSpace=<<white space>>
javaSymbol.characterLiteral=<<character literal>>
javaSymbol.comment=<<comment>>
javaSymbol.identifier=<<identifier>>
javaSymbol.integerLiteral=<<integer literal>>
javaSymbol.keyword=<<keyword>>
javaSymbol.newline=<<newline sequence>>
javaSymbol.realLiteral=<<real literal>>
javaSymbol.stringLiteral=<<string literal>>
javaSymbol.whitespace=<<white space>>
language.does.not.support.razorComment=Cannot use built-in RazorComment handler, language characteristics does not define the CommentStart, CommentStar and CommentBody known symbol types or parser does not override TokenizerBackedParser.OutputSpanBeforeRazorComment
parseError.atInCode.must.be.followed.by.colon.paren.or.identifier.start=The "@" character must be followed by a ":", "(", or a Java identifier.  If you intended to switch to markup, use an HTML start tag, for example:\
\
@if(isLoggedIn) {\
    <p>Hello, @user!</p>\
}
parseError.blockComment.not.terminated=End of file was reached before the end of the block comment.  All comments started with "/*" sequence must be terminated with a matching "*/" sequence.
parseError.blockNotTerminated=The "%1$s" block was not terminated.  All "%1$s" statements must be terminated with a matching "%2$s".
parseError.expected.closeBracket.before.eof=An opening "%1$s" is missing the corresponding closing "%2$s".
parseError.expected.endOfBlock.before.eof=The %1$s block is missing a closing "%2$s" character.  Make sure you have a matching "%2$s" character for all the "%3$s" characters within this block, and that none of the "%2$s" characters are being interpreted as markup.
parseError.expected.x=Expected "%1$s".
parseError.helpers.cannot.be.nested=Helper blocks cannot be nested within each other.
parseError.inheritsKeyword.must.be.followed.by.typeName=The 'inherits' keyword must be followed by a type name on the same line.
parseError.inlineMarkup.blocks.cannot.be.nested=Inline markup blocks (@<p>Content</p>) cannot be nested.  Only one level of inline markup is allowed.
parseError.markupBlock.must.start.with.tag=Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like "<br>".  Instead use self-closing tags like "<br/>".
parseError.missingCharAfterHelperName=Expected a "%1$s" after the helper name.
parseError.missingCharAfterHelperParameters=Expected a "%1$s" after the helper parameters.
parseError.missingEndTag=The "%1$s" element was not closed.  All elements must be either self-closing or have a matching end tag.
parseError.missingOpenBraceAfterSection=Sections cannot be empty.  The "@section" keyword must be followed by a block of markup surrounded by "{}".  For example:\
\
@section Sidebar {\
   <!-- Markup and text goes here -->\
}
parseError.namespaceImportAndTypeAlias.cannot.exist.within.codeBlock=Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an "@" character in markup.  It is recommended that you put them at the top of the page, as in the following example:\
\
@using System.Drawing;\
@{\
    // OK here to use types from System.Drawing in the page.\
}
parseError.namespaceOrTypeAliasExpected=The "Imports" keyword must be followed by a namespace or a type alias on the same line.
parseError.outerTagMissingName=Outer tag is missing a name. The first character of a markup block must be an HTML tag with a valid name.
parseError.razorComment.not.terminated=End of file was reached before the end of the block comment.  All comments that start with the "@*" sequence must be terminated with a matching "*@" sequence.
parseError.reservedWord="%1$s" is a reserved word and cannot be used in implicit expressions.  An explicit expression ("@()") must be used.
parseError.sections.cannot.be.nested=Section blocks ("%1$s") cannot be nested.  Only one level of section blocks are allowed.
# %1$s is only ever a single character
parseError.singleLine.controlFlowStatements.not.allowed=Expected a "%1$s" but found a "%2$s".  Block statements must be enclosed in "{" and "}".  You cannot use single-statement control-flow statements in RZHTML pages. For example, the following is not allowed:\
\
@if(isLoggedIn)\
    <p>Hello, @user</p>\
\
Instead, wrap the contents of the block in "{}":\
\
@if(isLoggedIn) {\
    <p>Hello, @user</p>\
}
parseError.textTagCannotContainAttributes="<text>" and "</text>" tags cannot contain attributes.
parseError.unexpected=Unexpected "%1$s"
parseError.unexpected.character.at.helper.name.start=Unexpected %1$s after helper keyword.  All helpers must have a name which starts with an "_" or alphabetic character. The remaining characters must be either "_" or alphanumeric.
parseError.unexpected.character.at.section.name.start=Unexpected %1$s after section keyword.  Section names must start with an "_" or alphabetic character, and the remaining characters must be either "_" or alphanumeric.
parseError.unexpected.character.at.start.of.codeBlock.java="%1$s" is not valid at the start of a code block.  Only identifiers, keywords, comments, "(" and "{" are valid.
parseError.unexpected.endOfFile.at.start.of.codeBlock=End-of-file was found after the "@" character.  "@" must be followed by a valid code block.  If you want to output an "@", escape it using the sequence: "@@"
parseError.unexpected.keyword.after.at=Unexpected "%1$s" keyword after "@" character.  Once inside code, you do not need to prefix constructs like "%1$s" with "@".
parseError.unexpected.nested.codeBlock=Unexpected "{" after "@" character. Once inside the body of a code block (@if {}, @{}, etc.) you do not need to use "@{" to switch to code.
parseError.unexpected.whiteSpace.at.start.of.codeBlock.java=A space or line break was encountered after the "@" character.  Only valid identifiers, keywords, comments, "(" and "{" are valid at the start of a code block and they must occur immediately following "@" with no space in between.
parseError.unexpectedEndTag=Encountered end tag "%1$s" with no matching start tag.  Are your start/end tags properly balanced?
parseError.unfinishedTag=End of file or an unexpected character was reached before the "%1$s" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing ("<br />") or have matching end tags ("<p>Hello</p>").  If you intended to display a "<" character, use the "&lt;" HTML entity.
parseError.unknownOption=Unknown option: "%1$s".
parseError.unterminated.string.literal=Unterminated string literal.  Strings that start with a quotation mark (") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@") can span multiple lines.
parseError.unterminatedHelperParameterList=Helper parameter list is missing a closing ")".
parser.context.not.set=Parser was started with a null Context property.  The Context property must be set BEFORE calling any methods on the parser.
parserContext.cannotCompleteTree.noRootBlock=Cannot complete the tree, StartBlock must be called at least once.
parserContext.cannotCompleteTree.outstandingBlocks=Cannot complete the tree, there are still open blocks.
parserContext.noCurrentBlock=Cannot finish span, there is no current block. Call StartBlock at least once before finishing a span
parserContext.parseComplete=Cannot complete action, the parser has finished. Only CompleteParse can be called to extract the final parser results after the parser has finished
parserError.sessionDirectiveMissingValue=Missing value for session state directive.
parserIsNotAMarkupParser=The parser provided to the ParserContext was not a Markup Parser.
# In RZHTML, the @section keyword is case-sensitive and lowercase (as with all Java keywords)
sectionExample.java=@section Header { ... }
structure.member.cannotBeNull=The %1$s property of the %2$s structure cannot be null.
symbol.unknown=<<unknown>>
tokenizer.cannotResumeSymbolUnlessIsPrevious=Cannot resume this symbol. Only the symbol immediately preceding the current one can be resumed.
tokenizerView.cannotPutBack=In order to put a symbol back, it must have been the symbol which ended at the current position. The specified symbol ends at %1$s, but the current position is %2$s
trace.backgroundThreadShutdown=[BG][%1$s] Shutdown
trace.backgroundThreadStart=[BG][%1$s] Startup
trace.changesArrived=[BG][%1$s] %2$s changes arrived
trace.changesDiscarded=[BG][%1$s] Discarded %2$s changes
trace.collectedDiscardedChanges=[BG][%1$s] Collecting %2$s discarded changes
trace.disabled=Disabled
trace.editorProcessedChange=[P][%1$s] %4$s Change in %3$s milliseconds: %2$s
trace.editorReceivedChange=[P][%1$s] Received Change: %2$s
trace.enabled=Enabled
trace.format=[Razor] %1$s
trace.noChangesArrived=[BG][%1$s] no changes arrived?
trace.parseComplete=[BG][%1$s] Parse Complete in %2$s milliseconds
trace.queuingParse=[M][%1$s] Queuing Parse for: %2$s
trace.startup=[Razor] Editor Tracing %1$s
trace.treesCompared=[BG][%1$s] Trees Compared in %2$s milliseconds. Different = %3$s

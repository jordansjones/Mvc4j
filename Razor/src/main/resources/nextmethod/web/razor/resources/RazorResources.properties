activeParser.must.be.code.or.markup.parser=The active parser must the same as either the markup or code parser.

# This is a literal used when composing parserError.* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.
blockName.code=code
# This is a literal used when composing parserError.* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.
blockName.explicitExpression=explicit expression

block.type.not.specified=Block cannot be built because a Type has not been specified in the BlockBuilder
cancelBacktrack.must.be.called.within.lookahead=The "cancelBacktrack" method can be called only while in a look-ahead process started with the "beginLookahead" method.
createCodeWriter.noCodeWriter=Cannot call createCodeWriter, a CodeWriter was not provided to the create method
endBlock.called.without.matching.startBlock="endBlock" was called without a matching call to "startBlock".
parserContext.cannotCompleteTree.noRootBlock=Cannot complete the tree, startBlock must be called at least once.
parserContext.cannotCompleteTree.outstandingBlocks=Cannot complete the tree, there are still open blocks.
parserContext.noCurrentBlock=Cannot finish span, there is no current block. Call StartBlock at least once before finishing a span.
parserContext.parseComplete=Cannot complete action, the parser has finished. Only completeParse can be called to extract the final parser results after the parser has finished
parseError.atInCode.must.be.followed.by.colon.paren.or.identifier.start=The "@" character must be followed by a ":", "(", or a Java identifier.  If you intended to switch to markup, use an HTML start tag, for example:\
	@if(isLoggedIn) { \
		<p>Hello, @user!</p>\
	}
parseError.blockNotTerminated=The "%0$s" block was not terminated.  All "%0$s" statements must be terminated with a matching "%1$s".
parseError.blockComment.not.terminated=End of file was reached before the end of the block comment.  All comments started with "/*" sequence must be terminated with a matching "*/" sequence.
parseError.expected.closeBracket.before.eof=An opening "%0$s" is missing the corresponding closing "%1$s".
parseError.expected.endOfBlock.before.eof=The %0$s block is missing a closing "%1$s" character.  Make sure you have a matching "%1$s" character for all the "%2$s" characters within this block, and that none of the "%1$s" characters are being interpreted as markup.
parseError.expected.x=Expected "%s".
parseError.inlineMarkup.blocks.cannot.be.nested=Inline markup blocks (@<p>Content</p>) cannot be nested.  Only one level of inline markup is allowed.
parseError.markupBlock.must.start.with.tag=Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like "<br>".  Instead use self-closing tags like "<br/>".
parseError.missingEndTag=The "%s" element was not closed.  All elements must be either self-closing or have a matching end tag.
parseError.missingOpenBraceAfterSection=Sections cannot be empty.  The "@section" keyword must be followed by a block of markup surrounded by "{}".  For example:\
	\
	@section Sidebar {\
	   <!-- Markup and text goes here -->\
	}
parseError.namespaceImportAndTypeAlias.cannot.exist.within.codeBlock=Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an "@" character in markup.  It is recommended that you put them at the top of the page, as in the following example:\
	\
	@using System.Drawing;\
	@{\
		// OK here to use types from System.Drawing in the page.\
	}
parseError.sections.cannot.be.nested=Section blocks ("%s") cannot be nested.  Only one level of section blocks are allowed.
parseError.singleLine.controlFlowStatements.not.allowed=Expected a "%0$s" but found a "%1$s".  Block statements must be enclosed in "{{" and "}}".  You cannot use single-statement control-flow statements in CSHTML pages. For example, the following is not allowed:\
	\
	@if(isLoggedIn)\
	    <p>Hello, @user</p>\
	\
	Instead, wrap the contents of the block in "{{}}":\
	\
	@if(isLoggedIn) {{\
	    <p>Hello, @user</p>\
	}}
parseError.textTagCannotContainAttributes="<text>" and "</text>" tags cannot contain attributes.
parseError.unexpectedEndTag=Encountered end tag "%s" with no matching start tag.  Are your start/end tags properly balanced?
parseError.unexpected.character.at.section.name.start=Unexpected %s after section keyword.  Section names must start with an "_" or alphabetic character, and the remaining characters must be either "_" or alphanumeric.
parseError.unexpected.character.at.start.of.codeBlock="%s" is not valid at the start of a code block.  Only identifiers, keywords, comments, "(" and "{" are valid.
parseError.unfinishedTag=End of file or an unexpected character was reached before the "%s" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing ("<br />") or have matching end tags ("<p>Hello</p>").  If you intended to display a "<" character, use the "&lt;" HTML entity.
parseError.unterminated.string.literal=Unterminated string literal.  Strings that start with a quotation mark (") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@") can span multiple lines.
parserIsNotAMarkupParser=The parser provided to the ParserContext was not a Markup Parser.
sectionExample=@section Header { ... }
tokenizer.cannotResumeSymbolUnlessIsPrevious=Cannot resume this symbol. Only the symbol immediately preceding the current one can be resumed.
tokenizerView.cannotPutBack=In order to put a symbol back, it must have been the symbol which ended at the current position. The specified symbol ends at %d, but the current position is %d